<!-- anchor: project-plan-title -->
# Project Plan: KingInYellow Personal Plugin Marketplace

**Version:** 1.0  
**Date:** 2026-01-11  
**Generated By:** Codex GPT-5 ProjectPlanner

<!-- anchor: project-overview -->
## 1. Project Overview

*   **Goal:** Deliver a git-native, CLI-first plugin marketplace that manages install/update/rollback/publish workflows with deterministic schemas, offline caches, and audit-ready automation tailored to a single maintainer.
*   **High-Level Requirements Summary:**
    - Ten end-to-end user journeys (install, update, rollback, browse, search, info, publish, pin, check updates, uninstall) must be available through consistent CLI ergonomics.
    - All plugin and marketplace metadata are governed by hardened JSON Schema Draft-07 definitions with AJV validation wired into both CLI and GitHub Actions.
    - Install and rollback flows must be atomic, cache-aware (last three versions, ≤500 MB), and symlink-based to guarantee 100% rollback success for cached versions.
    - Compatibility enforcement covers Node.js min/max, Claude Code runtime, OS, and architecture with clear warnings or hard stops plus logged evidence.
    - Lifecycle script execution is sandboxed, transparent, and requires typed trust confirmations with digests recorded for adversarial review traceability.
    - CI validation (lint, schema checks, vitest, Docker integrity) must finish under one minute for validation targets and expose artifacts for inspection.
*   **Key Assumptions:**
    - GitHub remains the sole remote source; any future mirrors stay behind feature flags and re-use the same git-native data contracts.
    - Example manifests under `examples/` warn but do not block releases if outdated, unless schema versions change.
    - Publishing relies on contributor-configured Git credentials; no bespoke auth layer is introduced in this phase.
    - Deprecated plugins show warning banners and require explicit confirmation before install or update recommendations proceed.

<!-- anchor: core-architecture -->
## 2. Core Architecture

*   **Architectural Style:** Layered CLI-centric monolith (`cli` ➜ `domain` ➜ `infrastructure`) with sealed contracts so packages can later be extracted into services without rewrites.
*   **Technology Stack:**
    *   Frontend: None (CLI UX rendered via Node.js + ANSI helpers, docs via Markdown/typedoc).
    *   Backend: Node.js 20 LTS, TypeScript strict mode, yargs for routing, zx-style shells, AJV for validation, vitest for testing.
    *   Database: git repository plus JSON stores inside `.claude-plugin/` (registry, cache index, telemetry, feature flags).
    *   Messaging/Queues: Not applicable; intra-process EventEmitter patterns only.
    *   Deployment: GitHub repository with Actions runners using Docker Node 20 slim images; local execution on macOS/Linux/WSL.
    *   Other Key Libraries/Tools: pnpm workspaces, ESLint, Prettier, typedoc, markdownlint, doctoc, OpenTelemetry exporters, node-config facade, ora/cli-table for UX.
*   **Key Components/Services:** CLI command layer, configuration + feature-flag service, marketplace index manager, plugin metadata validator, compatibility & policy engine, install transaction orchestrator, cache & storage manager, symlink activation service, lifecycle script sandbox, telemetry/audit logger, and CI validation runner. Component and sequence diagrams will elaborate responsibilities (see Section 2.1 artifacts, especially I1.T3 and I2.T3).
*   **Data Model Overview:** Core entities include `MarketplaceIndex`, `PluginEntry`, `PluginManifest`, `InstalledPluginRegistry`, `LifecycleScriptRecord`, `ChangelogMetadata`, and telemetry snapshots. Relationships emphasize cached artifacts, symlink targets, lifecycle consent digests, and compatibility verdict logs; an ERD captured in I1.T3 will illustrate constraints.
*   **API Contract Style:** Command contracts documented as Markdown/OpenAPI-like schemas for each CLI operation, ensuring automation can feed JSON envelopes to the CLI. Specification files produced in I2.T4 will outline parameters, envelopes, error codes, and telemetry hooks.
*   **Communication Patterns:** Synchronous CLI-to-domain invocations with strict DTOs; domain orchestrators call infrastructure adapters for git/fs/schema/sandbox operations. Sequence diagrams (I2.T3) will document request/response choreography for install/update/rollback, highlighting atomic staging and rollback checkpoints.

<!-- anchor: key-artifacts-planned -->
## 2.1. Key Architectural Artifacts Planned

*   Component Diagram (Mermaid) – Depict CLI, domain, infrastructure, and persistence boundaries for shared understanding (created/refined in `I1.T3`).
*   Database ERD (PlantUML) – Visualize key JSON entities and relationships covering cache/registry/telemetry flows (delivered in `I1.T3`).
*   Install & Rollback Sequence Diagram (PlantUML) – Capture end-to-end orchestration including lifecycle sandboxing and telemetry hooks (produced during `I2.T3`).
*   CLI Contract Catalog (Markdown + JSON Schema) – Define request/response envelopes, error codes, and feature-flag annotations for all commands (initial draft in `I2.T4`, maintained afterward).
*   CI Validation Pipeline Spec (Markdown) – Detail GitHub Actions jobs, Docker images, runtime budgets, and artifact expectations to keep CRIT-021 compliance auditable (generated in `I4.T3`).
*   Operational Runbook & Metrics Spec (Markdown) – Outline cache recovery, registry repair, telemetry export steps, and KPI definitions referencing Section 6 strategy (assembled in `I4.T4`).

<!-- anchor: directory-structure -->
## 3. Directory Structure

Root Directory: `yellow-plugins-cli/`

```
yellow-plugins-cli/
├── package.json                # pnpm workspace root (cli, domain, infrastructure packages)
├── pnpm-workspace.yaml         # Declares package boundaries and shared scripts
├── tsconfig.base.json          # Shared compiler options (ESM, strict)
├── docs/
│   ├── SPECIFICATION.md        # Provided spec plus addenda
│   ├── plans/                  # Generated architecture artifacts (this plan, ADRs)
│   ├── diagrams/               # PlantUML/Mermaid sources for component, ERD, sequences
│   ├── operations/             # Runbooks, observability guides, feature-flag matrix
│   └── contracts/              # CLI command schemas, API envelopes, DTO references
├── api/
│   └── cli-contracts/          # Machine-readable JSON/YAML for CLI request/response schemas
├── packages/
│   ├── cli/                    # yargs commands, UX components, logging adapters
│   ├── domain/                 # Interfaces, orchestrators (install, compatibility, cache)
│   └── infrastructure/         # Git/fs/schema/sandbox adapters, telemetry writers
├── scripts/
│   ├── validate-marketplace.js # Provided schema runners wired into CLI commands
│   ├── validate-all-plugins.js
│   └── bootstrap.ts            # Environment checks, feature-flag scaffolding
├── schemas/
│   ├── marketplace.schema.json # Provided spec (imported, extended via tooling)
│   └── plugin.schema.json
├── .claude-plugin/
│   ├── config.json             # Config precedence defaults
│   ├── flags.json              # Feature toggle states per environment
│   ├── registry.json           # Installed plugin registry (atomic writes)
│   ├── cache/                  # Cached plugin versions, eviction metadata
│   ├── audit/                  # Structured logs for lifecycle consent & telemetry
│   └── tmp/                    # Transaction staging directories
├── .github/
│   └── workflows/
│       └── validate-schemas.yml# CI pipeline (lint, tests, schema validation, Docker)
├── Dockerfile                  # Node 20 slim, pinned digest, used by CI
├── README.md                   # Project introduction + quickstart
├── CONTRIBUTING.md             # Process, feature-flag rules, traceability checklists
└── .codemachine/artifacts/     # Generated planning artifacts (plan, diagrams, manifest)
```

<!-- anchor: directives-and-process -->
## 4. DIRECTIVES & STRICT PROCESS

*   **Command Usage Discipline:** Follow the provided protocol—no exploratory listing commands outside explicit need; leverage scripted tooling and targeted queries instead of ad-hoc shelling.
*   **Feature-Flag Governance:** All iterative additions land behind `.claude-plugin/flags.json` toggles with documented ownership; enable flags in CLI preflight only when corresponding ADRs exist.
*   **Traceability Enforcement:** Every change references FR/NFR IDs plus CRIT corrections; update `docs/traceability-matrix.md` alongside code, diagrams, and contracts to preserve 100% coverage.
*   **Atomic Persistence:** Registry, cache index, and telemetry writes must use temp file + rename semantics and record `transactionId` for each install/update/rollback/uninstall.
*   **Security & Observability:** Lifecycle scripts require digest display + typed consent (`"I TRUST THIS SCRIPT"`); structured JSON logs and Prometheus snapshots are produced per command and archived in CI artifacts.
*   **Performance Budgets:** Install ≤ 2 minutes and publish ≤ 10 minutes under nominal conditions; CI validation (lint + schemas + tests) stays under one minute for validation jobs, tracked via metrics and documented in Section 6.
*   **Documentation Synchronization:** typedoc, doctoc, and markdownlint run in CI; architecture artifacts (Section 2.1) must be regenerated when interfaces shift, and ADRs capture deviations before implementation.
