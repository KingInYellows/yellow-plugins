<!-- anchor: system-architecture-blueprint -->
# System Architecture Blueprint: KingInYellows Personal Plugin Marketplace

**Version:** 1.0
**Date:** 2026-01-11
**Generated By:** Structural_Data_Architect

<!-- anchor: 1-introduction-goals -->
## 1. Introduction & Goals

*   **1.1. Project Vision:** Provide a git-native CLI marketplace that lets a solo developer install, publish, and manage Claude-oriented plugins with deterministic contracts, fast validation, and offline-ready caches. The architecture keeps everything inside the repository so that every action is auditable, reproducible, and aligned with the nine-week phased roadmap. The vision emphasizes layering the CLI, domain, and infrastructure packages so responsibilities stay clear even as scope expands beyond Phase 1. It doubles down on git-native persistence, meaning all data flows through tracked JSON files, cache directories, and Git operations for transparent auditing.

*   **1.2. Key Objectives:**
    *   Deliver install, update, rollback, browse, search, info, publish, pin, check-updates, and uninstall journeys with symmetric command ergonomics so the interface feels cohesive across all workflows.
        Consistent help text, feature flag gating, and structured logging keep every journey approachable even as new capabilities arrive.
    *   Guarantee 100% rollback coverage for cached versions by enforcing atomic transaction orchestration, staging directories, and preflight compatibility checks before mutating the active plugin registry.
        Each transaction records a `transactionId`, cache path, and symlink state so that recovery steps are deterministic and reviewable.
    *   Enforce schema-driven quality via AJV-backed marketplace and plugin validation so that manifests, lifecycle hooks, and permission disclosures remain trustworthy throughout the repo lifecycle.
        Validation errors map directly to specification error codes, ensuring documentation and CLI behavior stay in lockstep.
    *   Surface compatibility verdicts for Node.js, Claude Code runtime, OS, and arch dimensions to prevent broken installs before they start, and persist those results for later audits.
        Compatibility warnings can be inspected offline because their inputs and outputs are captured alongside the installed registry.
    *   Keep operations within the `.claude-plugin/` hierarchy, including caches, config, telemetry, and feature flags, to honor the git-native persistence model and avoid external databases.
        Atomic writes via temp files plus rename semantics protect against partial state even when commands are interrupted.
    *   Feed structured logs, metrics, and changelog retrieval status into audit-friendly outputs that CI can scoop up for adversarial review traceability.
        Each command attaches correlation IDs so a single install can be traced across local logs, Prometheus snapshots, and GitHub workflow artifacts.

*   **1.3. Scope:** The blueprint covers the CLI monolith, domain services, infrastructure adapters, cache directories, registries, schema files, and GitHub workflow glue that all reside within the repository boundaries. External services like GitHub, local shell environments, and IDE integrations are documented only as interaction points, not as managed assets. Phase 2 discovery enhancements and future GUI ideas remain out of scope beyond the hooks and feature flags required to enable them later.
    *   In-scope functional areas include command parsing, feature flag evaluation, marketplace ingestion, metadata validation, compatibility policy enforcement, install/update/rollback orchestration, cache eviction, symlink activation, lifecycle sandboxing, telemetry logging, configuration management, and CI validation workflows.
        Each of these areas maps directly to domain components enumerated in the blueprint foundation to ensure coverage of FR-001 through FR-013.
    *   In-scope data assets include `marketplace.json`, plugin manifests, `.claude-plugin/cache/**`, `.claude-plugin/registry.json`, lifecycle consent journals, telemetry files, and schema/contract documentation under `docs/`.
        These files represent the official persistence model and must respect atomic write semantics plus git-friendly diffing.
    *   In-scope diagrams include C4 context/container/component visuals and a PlantUML ERD stored alongside the documentation set for reuse by other architects.
        The diagrams intentionally emphasize static structure rather than runtime interactions to respect the Structural_Data_Architect remit.
    *   Out-of-scope capabilities include remote marketplace mirroring, GUI dashboards, managed authentication systems, or hosted databases; they are acknowledged only through feature flags or assumptions that gate future experimentation.
        Any future adoption of those patterns would require a revised foundation document and traceability updates.
    *   Operational concerns such as release automation, monitoring dashboards, or runtime scaling are excluded except where structural artifacts must support them indirectly (e.g., telemetry file formats).
        Those responsibilities fall to other specialized architects once the structural baseline is solid.

*   **1.4. Key Assumptions:** Search ranking defaults to deterministic category/name/version ordering until telemetry justifies alternative heuristics, and the CLI exposes feature flags so experiments stay isolated. Publishing relies on existing Git credentials rather than bespoke auth flows, and example manifests emit warnings instead of blocking releases unless schema versions change. Deprecated plugins stay discoverable but show critical warnings and never appear in automated recommendations, while lifecycle scripts demanding elevated permissions must explain why or they are blocked. GitHub remains the single source of truth for remote distribution, and any mirror exploration stays behind the `experimentalMirrorSync` flag captured in config.
    *   Assumption-led guardrails mean that every structural decision references the same precedence rules (CLI flags > environment variables > config files) delivered via a single `config.ts` accessor.
        This prevents divergent interpretation of configuration sources between the CLI, domain services, and infrastructure adapters.
    *   Offline-first expectations imply that caches, telemetry, and validation artifacts remain useful when disconnected; therefore the blueprint ensures no component requires live APIs once manifests and archives are fetched.
        Eviction policies and cache ceilings are encoded structurally so behavior remains predictable.
    *   Lifecycle script safety hinges on displaying content, capturing "I TRUST THIS SCRIPT" consent, and refusing scripts without justification strings.
        Structural components therefore dedicate storage for `LifecycleScriptRecord` entities, even before enforcement expands in Phase 2.

<!-- anchor: 2-architectural-drivers -->
## 2. Architectural Drivers

*   **2.1. Functional Requirements Summary:** The CLI must parse and execute ten user journeys across install, management, and publishing, each with consistent UX patterns, typed inputs, and explicit error codes drawn from the 23-scenario catalog. Marketplace ingestion, plugin manifest validation, compatibility analysis, lifecycle script sandboxing, cache eviction, pinning, telemetry generation, and uninstall cleanup all stem directly from FR-001 through FR-013 and therefore shape every boundary in this blueprint. Every requirement threads back to git-native persistence, so even features like browse/search lean on local marketplace snapshots instead of remote APIs.
    *   FR-001 through FR-004 address discovery, install, and rollback operations, demanding that the CLI orchestrate staging directories and version-aware registries.
        The architecture therefore elevates the Install Transaction Orchestrator and Cache Manager as first-class domain components.
    *   FR-005 through FR-008 govern publishing, pinning, and update checking, forcing the system to reconcile local registry state with marketplace entries and remote git status.
        This necessitates compatibility between CLI semantics and GitHub-hosted workflows so that pushes trigger validation consistently.
    *   FR-009 through FR-013 cover uninstall, conflict handling, telemetry, and documentation output, which explains the dedicated Lifecycle Sandbox, Symlink Activation Layer, and Telemetry Logger.
        Their inclusion ensures that even failure paths remain deterministic and traced back to the same structural elements.

*   **2.2. Non-Functional Requirements (NFRs):** Install commands must complete under two minutes and publish under ten minutes, forcing efficient cache access, minimal network hops, and deterministic git interactions. 100% rollback success for cached versions requires atomic temp-directory promotions, transaction identifiers, and durability of the installed registry file. Observability mandates structured JSON logs with correlation IDs, Prometheus-friendly metrics snapshots, and OpenTelemetry traces that CI can capture as artifacts. Security constraints require sandboxed lifecycle scripts, trust confirmations, permission disclosure messaging, and refusal to persist secrets. Offline-first behavior demands local caching of manifests, plugin archives, and compatibility verdicts so work can continue without a network. CI runtimes must validate schemas under one minute, which keeps JSON schema evaluation, duplicate detection, and dependency checks lightweight yet comprehensive.
    *   Performance guardrails influence container boundaries because each layer must avoid redundant JSON parsing or git invocations; caching marketplace signatures directly inside the domain services reduces expensive re-validation.
        The CLI retains summary data to present status quickly even before detailed fetches complete.
    *   Reliability requirements motivate transaction logs and telemetry snapshots, so the structural blueprint dedicates registry fields for `transactionId`, `installState`, and compatibility verdicts.
        This ensures that audit trails survive even after caches rotate.
    *   Security and compliance constraints lead to a dedicated Lifecycle Sandbox component plus configuration stores that never persist secrets, aligning with CRIT-004 and CRIT-003 corrections.
        Observability of consent plus script digests becomes part of the structural data model rather than ad-hoc logging.

*   **2.3. Constraints & Preferences:** The architectural style is a layered CLI-first monolith partitioned into `cli`, `domain`, and `infrastructure` packages, and cross-layer imports must never break directionality. Node.js 20 LTS with TypeScript, yargs, zx-style helpers, and AJV is mandatory, with ESLint strict settings enforcing runtime safety. Pnpm controls dependencies and lockfile determinism, vitest drives tests, typedoc documents APIs, markdownlint and doctoc keep Markdown clean, and Docker Node 20 slim images support reproducible CI. Git is the only database and `.claude-plugin/` houses registries, caches, flags, and config; no external DBs or messaging systems are allowed. GitHub Actions is the sole CI/CD orchestrator, Prometheus metrics stay local, and feature flags reside in `.claude-plugin/flags.json` so commands can be toggled without code forks.
    *   Preference for CLI-first ergonomics means no GUI or web frontend may be added without revising the foundation.
        Documentation therefore focuses on markdown guides and typedoc outputs.
    *   Strict ESLint/tsconfig settings (`strict: true`, ESM modules) require that interfaces be fully typed, encouraging domain services to expose explicit contracts that other architects can rely on.
        Any deviation would be caught during lint/test steps enforced by CI workflows.
    *   The repository's git-native identity forbids external databases or message queues, so concurrency is handled through filesystem locks and atomic renames rather than distributed systems.
        Cache eviction policies and feature flags rely solely on JSON files committed to the repo for transparency.

<!-- anchor: 3-proposed-architecture -->
## 3. Proposed Architecture (Structural View)

*   **3.1. Architectural Style:** The solution follows the mandated layered CLI-first monolith partitioned into `cli`, `domain`, and `infrastructure` packages, yielding clear seams so future services can peel off without rewriting core logic. The CLI package owns presentation (yargs commands, UX, confirmations, logging), the domain package defines interfaces and orchestrates marketplace, validation, compatibility, install, cache, symlink, and telemetry logic, and the infrastructure package supplies adapters for filesystem, git, AJV validators, shell execution, and telemetry sinks. Dependence flows strictly downward (CLI → domain → infrastructure), while shared typed contracts reside in the domain layer to prevent duplication. Domain interface definitions (Result types, contract DTOs, error enumerations) are versioned so Behavior and Ops architects can collaborate without stepping on infrastructure code. Infrastructure adapters expose only the minimal functions (git, fs, schema, sandbox, telemetry) to reduce surface area and preserve change isolation.

*   **3.2. Technology Stack Summary:**

    | Layer / Capability | Technology | Purpose / Notes |
    | --- | --- | --- |
    | CLI Command Layer | Node.js 20 LTS + TypeScript + yargs | Parses commands, enforces feature flags, handles confirmations, surfaces structured logs |
    | Domain Services | TypeScript interfaces, strict tsconfig, ESLint | Encapsulates marketplace, validation, compatibility, cache, install, and telemetry orchestration |
    | Infrastructure Adapters | zx-style helpers, AJV (Draft-07), fs/promises, simple-git | Executes git operations, schema validation, lifecycle sandboxing, symlink and atomic writes |
    | Persistence | Git repository + `.claude-plugin/` JSON files + cache directories | Maintains marketplace snapshots, installed registry, lifecycle consent records, eviction metadata |
    | Package Management | pnpm | Locks dependencies deterministically across packages |
    | Testing | vitest + snapshot fixtures + tmp git repos | Covers unit, integration, and transactional install scenarios |
    | Documentation | typedoc, markdownlint, doctoc, Mermaid (optional) | Documents APIs, keeps Markdown navigable, stores diagrams under `docs/diagrams/` |
    | Observability & Metrics | Structured JSON logs, Prometheus snapshots via `npm run metrics`, OpenTelemetry traces | Provides audit logs for adversarial review and CI artifact uploads |
    | CI/CD | GitHub Actions workflows + Docker Node 20 slim images | Runs validation scripts, linting, testing, docker builds, artifact uploads |
    | Configuration & Flags | `.claude-plugin/config.json`, `.claude-plugin/flags.json`, single `config.ts` accessor | Centralizes precedence rules (CLI > env > file) and toggles features |
    | Feature Security | Lifecycle sandbox helper, typed confirmation prompts | Displays scripts, enforces "I TRUST THIS SCRIPT", blocks missing permission justifications |

    This stack combination ensures that every dependency is already sanctioned by the foundation, minimizing variance between local and CI environments. Strict layering plus pnpm workspace boundaries make it easy to convert packages into services later without rewriting domain logic, delivering future-proof seams for scale.

*   **3.3. System Context Diagram (C4 Level 1):**
    *   **Description:** KingInYellow interacts with the Yellow Plugins CLI from a local terminal or IDE task runner, while GitHub remote repositories, GitHub Actions, local workspace files, and telemetry collectors provide supporting capabilities. The CLI treats Git, filesystem paths, and schema files as its primary data stores, and emits logs plus metrics that CI can capture for audits, satisfying the offline-first, git-native constraint.
        - CLI interactions require explicit lifecycle confirmations and structured logging to respect security findings CRIT-003 and CRIT-004.
        - GitHub remote repositories host marketplace state and plugin manifests, while Actions enforce schema and compatibility rules asynchronously.
        - Telemetry and local workspace components guarantee offline continuity by storing caches, registry files, and metrics locally.
    *   **Diagram (PlantUML):**
        ~~~plantuml
        @startuml
        !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml
        LAYOUT_LEFT_RIGHT()
        ' Context diagram describing external actors and the CLI system boundary.
        ' The CLI is central while externals act as sources/sinks for git, storage, and observability.

        ' Actor definitions anchor the user journeys.
        Person(dev, "KingInYellow", "Solo developer administering plugins and marketplace content")
        ' The developer is both the consumer and curator of the plugin ecosystem.
        Person_Ext(editor, "IDE / Claude Code", "Invokes CLI tasks, displays validation feedback")
        ' IDE integrations mirror automation ergonomics.

        ' System definitions capture primary collaborators.
        System(cli, "Yellow Plugins CLI", "Layered CLI-first monolith handling install, publish, and validation commands")
        ' The CLI encloses CLI/domain/infra packages and enforces atomic operations.
        System_Ext(github, "GitHub Remote Repository", "Hosts marketplace index, plugin sources, and Actions workflows")
        ' GitHub remains the single source of truth for manifests and CI automation.
        System_Ext(ci, "GitHub Actions Workflow", "Validates schemas, runs tests, and uploads audit artifacts")
        ' CI ensures every commit satisfies schema and validation contracts.
        System_Ext(localfs, "Local Workspace & Cache", ".claude-plugin directory storing registries, caches, feature flags")
        ' Local filesystem persistence unlocks offline-first behavior and deterministic rollbacks.
        System_Ext(telemetry, "Telemetry Collector", "Prometheus snapshot exporter plus JSON log sink")
        ' Telemetry summarizes structured logs for adversarial review traceability.
        System_Ext(shellEnv, "Local Shell Environment", "zsh + pnpm runtime executing CLI commands")
        ' The shell/environment controls config precedence and pnpm context.

        ' Relationships expressing command usage and confirmations.
        Rel(dev, cli, "Runs CLI commands, confirms lifecycle scripts, reviews logs", "Terminal UX")
        ' This line covers install/update/rollback/publish journeys initiated by the operator.
        Rel(editor, cli, "Launches scripted commands, surfaces warnings inline", "Task runner integration")
        ' IDE automation ensures parity with manual workflows.

        ' Relationships describing resource interactions.
        Rel(cli, github, "Fetches marketplace.json, pulls plugin manifests, pushes publish commits", "Git over SSH / HTTPS")
        ' Git-native persistence ensures every change is versioned and auditable.
        Rel(cli, ci, "Triggers workflows via git push and monitors validation status", "GitHub API & status checks")
        ' CI gating enforces schema compliance before merges.
        Rel(cli, localfs, "Reads/writes config, cache, registry, telemetry files", "Atomic filesystem operations")
        ' Atomic IO supports 100% rollback coverage for cached versions.
        Rel(cli, telemetry, "Streams structured logs, metrics, OpenTelemetry traces", "stdout artifacts + local files")
        ' Observability outputs feed both local diagnostics and CI uploads.
        Rel(cli, shellEnv, "Inherits config, env vars, feature flag overrides", "Process environment")
        ' Configuration precedence is enforced through the single config module.
        Rel(ci, github, "Reports validation results, stores workflow artifacts", "GitHub-hosted pipelines")
        ' GitHub stores CI outcomes and attaches them to commits.
        Rel(telemetry, ci, "Provides collected metrics/logs for archival", "Workflow artifact upload")
        ' Telemetry outputs are archived for auditing and adversarial review.

        ' Additional documentation notes highlight offline-first behavior and audit needs.
        ' Caches, registries, and telemetry remain accessible without network connectivity.
        ' Feature flags and configuration live inside the repository to support deterministic builds.

        ' Ensure legend clarifies styling for people, systems, and externals.
        SHOW_LEGEND()
        @enduml
        ~~~

*   **3.4. Container Diagram (C4 Level 2):**
    *   **Description:** The CLI system contains distinct containers that mirror the mandated packages: CLI command layer, domain services, and infrastructure adapters, plus repository-backed data stores for caches and installed registries. External containers include GitHub remote repos, GitHub Actions workflows, local shell runtime, and telemetry collectors; each relationship enforces the git-native persistence model and offline-friendly behavior.
        - CLI container owns UX, feature flags, and logging while delegating all stateful work to domain services.
        - Domain services coordinate validation, compatibility, install orchestration, cache management, and telemetry so other architects can integrate without touching infrastructure code.
        - Infrastructure adapters encapsulate git, filesystem, schema validation, lifecycle sandboxing, and telemetry sinks, keeping platform-specific logic localized.
    *   **Diagram (PlantUML):**
        ~~~plantuml
        @startuml
        !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml
        LAYOUT_LEFT_RIGHT()
        ' Container diagram showing internal packages and supporting stores.
        ' Emphasizes CLI/domain/infra layering with supporting configuration and telemetry stores.

        Person(dev, "KingInYellow", "Solo operator of the CLI marketplace")
        ' The single developer interacts through terminals or IDE tasks.

        System_Boundary(yellowcli, "Yellow Plugins CLI System") {
            ' CLI container definition
            Container(cliLayer, "CLI Command Layer", "TypeScript + yargs", "Parses commands, enforces feature flags, gathers telemetry context")
            ' Domain container definition
            Container(domainLayer, "Domain Services Package", "TypeScript (strict)", "Marketplace, validation, compatibility, install, cache orchestration")
            ' Infrastructure container definition
            Container(infraLayer, "Infrastructure Adapters", "TypeScript adapters + zx helpers + AJV", "Git, filesystem, schema validation, lifecycle sandboxing")
            ' Cache store definition
            ContainerDb(cacheStore, ".claude-plugin Cache", "Staged directories + checksums", "Stores downloaded plugin archives, last three versions, eviction logs")
            ' Registry store definition
            ContainerDb(registryStore, "Installed Plugin Registry", "JSON registry", "Tracks installed plugins, symlinks, pins, telemetry snapshots")
            ' Flags/config store definition
            ContainerDb(flagsConfig, "Configuration & Flags", "config.json + flags.json", "Holds precedence-controlled configuration and feature toggles")
            ' Telemetry sink definition
            Container(telemetryCollector, "Telemetry & Metrics Collector", "Prometheus snapshot script + JSON log sink", "Captures install/update metrics and structured logs")
        }

        ' External containers that interact with the CLI system
        Container_Ext(githubRepo, "GitHub Remote Repository", "Git hosting, PR workflow", "Canonical source for marketplace index and plugin manifests")
        Container_Ext(ciWorkflow, "GitHub Actions Validation Workflow", "Docker Node 20 slim", "Runs schema validation, linting, vitest, docker build")
        Container_Ext(shellEnv, "Local Shell Runtime", "zsh + pnpm + Node 20", "Executes CLI, supplies env vars, manages pnpm store")

        ' Interaction from human to CLI
        Rel(dev, cliLayer, "Executes CLI commands, reviews output")
        ' Human interaction enforces typed confirmations for lifecycle scripts.

        ' Shell environment supplies runtime context
        Rel(shellEnv, cliLayer, "Provides environment configuration and pnpm context")
        ' CLI inherits config precedence from the shell and config files.

        ' Layered interactions internal to the monolith
        Rel(cliLayer, domainLayer, "Invokes command handlers and domain services via typed interfaces", "In-process")
        ' Command handlers never bypass domain interfaces.
        Rel(domainLayer, infraLayer, "Uses adapters for git, fs, schema validation, telemetry sinks", "In-process")
        ' Domain logic avoids direct IO to preserve testability.

        ' Infra connections to persistence stores
        Rel(infraLayer, cacheStore, "Writes and promotes staged artifacts", "Atomic filesystem operations")
        ' Cache promotions occur only after validation succeeds.
        Rel(infraLayer, registryStore, "Commits transaction metadata, pins, lifecycle records", "JSON write via temp files")
        ' Registry updates carry transaction IDs for rollback.
        Rel(domainLayer, flagsConfig, "Reads feature flags and configuration defaults", "Single config module accessor")
        ' Feature flags gate experimental commands uniformly.

        ' Observability flows
        Rel(cliLayer, telemetryCollector, "Emits structured logs & metrics per command", "stdout + file sink")
        ' Logs capture correlationId, command, pluginId.
        Rel(telemetryCollector, ciWorkflow, "Uploads metrics/log files for adversarial review", "Workflow artifacts")
        ' CI archives telemetry for review continuity.

        ' Git interactions
        Rel(infraLayer, githubRepo, "Fetches marketplace index, pushes publish commits, pulls plugin archives", "Git + HTTPS APIs")
        ' GitHub is the only remote data source.
        Rel(ciWorkflow, githubRepo, "Validates branches, enforces schema + dependency rules", "GitHub-hosted automation")
        ' Workflows ensure PRs meet validation requirements.
        Rel(cliLayer, ciWorkflow, "Triggers workflows by pushing commits, reads status badges", "Git refs & APIs")
        ' CLI guides the user to remediation steps when CI fails.

        ' Cache-registry linkage highlighting rollback guarantees
        Rel(cacheStore, registryStore, "Shares cache paths referenced by installed plugin entries", "File path references")
        ' Registry entries know which cache artifact produced the install.

        ' Additional commentary: configuration store enforces consistent precedence, while telemetry sink formalizes auditability.
        ' These structural relationships satisfy cross-cutting concerns defined in the foundation.

        SHOW_LEGEND()
        @enduml
        ~~~

*   **3.5. Component Diagram (C4 Level 3 - Domain Services Container):**
    *   **Description:** The domain package contains cohesive components that represent the system's canonical services: marketplace index management, plugin validation, compatibility enforcement, install transaction orchestration, cache management, symlink activation, lifecycle sandbox coordination, and telemetry/audit logging. Each component exposes interfaces consumed by the CLI command handlers while relying on infrastructure adapters for IO, ensuring strict separation of concerns and future-proof seams.
        - Marketplace and validation services protect data quality before any mutation occurs.
        - Install, cache, symlink, and lifecycle components enforce CRIT-001, CRIT-002, CRIT-010, and CRIT-011 corrections by structuring transactions and consent flows.
        - Telemetry logger captures outputs for adversarial review while respecting observability directives.
    *   **Diagram (PlantUML):**
        ~~~plantuml
        @startuml
        !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml
        LAYOUT_LEFT_RIGHT()
        ' Component view for the Domain Services container.
        ' Highlights command routing, domain interfaces, and adapter collaboration.

        Container(cliLayer, "CLI Command Layer", "TypeScript + yargs", "Command router, UX, confirmation prompts")
        ' CLI acts as consumer of domain interfaces.
        Container(infraLayer, "Infrastructure Adapters", "Git, fs, AJV, lifecycle sandbox", "Provides concrete IO operations")
        ' Adapters encapsulate platform-specific behaviors.

        Container_Boundary(domainBoundary, "Domain Services Package") {
            Component(indexManager, "Marketplace Index Manager", "Domain service", "Fetches marketplace.json, validates, caches signatures, exposes read APIs")
            ' Maintains local marketplace state for browse/search journeys.
            Component(pluginValidator, "Plugin Metadata Validator", "Domain service", "Runs AJV schemas, business rules, permission disclosures")
            ' Ensures manifest compliance with Draft-07 and business rules.
            Component(compatEngine, "Compatibility & Policy Engine", "Domain service", "Evaluates OS/arch/Node/Claude compatibility, emits verdicts")
            ' Blocks incompatible installs upfront.
            Component(installOrchestrator, "Install Transaction Orchestrator", "Domain service", "Staging directories, checksum verification, atomic registry writes, rollback control")
            ' Enforces transaction boundaries for install/update/rollback/uninstall.
            Component(cacheManager, "Cache & Storage Manager", "Domain service", "Enforces 500 MB cap, last-three-versions rule, eviction logs")
            ' Balances offline readiness with storage ceilings.
            Component(symlinkActivator, "Symlink Activation Layer", "Domain service", "Creates/validates symlinks, ensures idempotent activation/deactivation")
            ' Connects active plugin directory to cached artifacts.
            Component(lifecycleSandbox, "Lifecycle Script Sandbox", "Domain service", "Displays scripts, records trust confirmations, coordinates controlled execution")
            ' Honors script safety requirements before running hooks.
            Component(telemetryLogger, "Telemetry & Audit Logger", "Domain service", "Builds structured JSON logs, Prometheus metrics, OpenTelemetry traces")
            ' Keeps observability data consistent across commands.
        }

        ' CLI to domain relationships
        Rel(cliLayer, indexManager, "Requests marketplace data for browse/search/info journeys")
        ' CLI needs curated datasets for discovery features.
        Rel(cliLayer, pluginValidator, "Validates plugin manifests before install/publish")
        ' Prevents invalid payloads from reaching disk.
        Rel(cliLayer, compatEngine, "Asks for compatibility verdicts to block or warn users")
        ' Blocks unsupported OS/arch/node combos.
        Rel(cliLayer, installOrchestrator, "Delegates install/update/rollback/uninstall execution")
        ' Command handlers remain stateless.
        Rel(cliLayer, telemetryLogger, "Supplies command metadata for logging")
        ' Ensures correlation IDs propagate through logs.

        ' Domain to infrastructure relationships
        Rel(indexManager, infraLayer, "Uses git adapter + filesystem cache", "Pull + read")
        ' Git + fs interactions stay in adapters.
        Rel(pluginValidator, infraLayer, "Invokes AJV schema validator and schema files", "Validate JSON")
        ' Schema evaluation occurs via AJV adapter.
        Rel(compatEngine, infraLayer, "Reads OS/arch/node data from environment + manifest", "System introspection")
        ' Compatibility uses environment helpers.
        Rel(installOrchestrator, infraLayer, "Leverages filesystem, git, checksum utilities", "Atomic IO")
        ' Staging and promotion rely on adapters.
        Rel(cacheManager, infraLayer, "Manages directories, calculates sizes, applies evictions", "Filesystem ops")
        ' Cache policy enforcement uses fs utilities.
        Rel(symlinkActivator, infraLayer, "Creates/validates symlinks inside plugin directories", "fs symlink")
        ' Activation uses OS-specific symlink APIs.
        Rel(lifecycleSandbox, infraLayer, "Spawns sandboxed subprocesses, enforces timeouts", "zx helper")
        ' Lifecycle execution stays isolated.
        Rel(telemetryLogger, infraLayer, "Writes JSON logs, metrics files, OTEL spans", "fs + stdout")
        ' Telemetry relies on file + stdout adapters.

        ' Domain component collaborations
        Rel(cacheManager, installOrchestrator, "Supplies cached artifacts and eviction decisions")
        ' Ensures installs pull from verified cache entries.
        Rel(installOrchestrator, symlinkActivator, "Activates plugin after successful transaction")
        ' Activation happens only after all checks pass.
        Rel(installOrchestrator, lifecycleSandbox, "Runs lifecycle scripts at pre/post/uninstall checkpoints")
        ' Hooks keep compatibility with plugin authors.
        Rel(installOrchestrator, pluginValidator, "Requests re-validation before promotion")
        ' Prevents stale manifests from slipping through.
        Rel(telemetryLogger, cacheManager, "Records cache usage metrics, eviction events")
        ' Observability surfaces storage pressure.
        Rel(telemetryLogger, compatEngine, "Logs compatibility warnings/errors with correlation IDs")
        ' Audit logs retain compatibility decisions.

        ' Additional notes: component boundaries align with the "Blueprint" section of the foundation, ensuring no surprise coupling.
        ' Interfaces remain portable should services be extracted later.

        SHOW_LEGEND()
        @enduml
        ~~~

*   **3.6. Data Model Overview & ERD:**
    *   **Description:** Core data entities include the marketplace index (with versioned entries), plugin entries (linking to manifests and changelog metadata), plugin manifests (with compatibility, lifecycle, and permissions data), the installed plugin registry (capturing install state, cache paths, transaction IDs, and telemetry snapshots), lifecycle script records (tracking consent digests and execution metadata), and changelog metadata (recording retrieval outcomes). These entities live as JSON documents within the git repository and `.claude-plugin/` directory, ensuring offline auditing and deterministic behavior.
        - MarketplaceIndex anchors repository-level provenance, including generator versions and signatures for tamper detection.
        - PluginEntry surfaces curated metadata plus changelog links and deprecation flags, enabling search/browse journeys.
        - PluginManifest houses lifecycle scripts, permissions, compatibility dimensions, and optional config schema fragments so compatibility can be enforced without network access.
        - InstalledPluginRegistry persists current installations, pins, telemetry snapshots, and relationships to cache paths, ensuring rollback feasibility and audit history.
        - LifecycleScriptRecord captures consent digests, execution timings, and justification strings so CRIT-004 compliance is codified into storage.
        - ChangelogMetadata stores retrieval status, timestamps, and failure reasons for CRIT-008 fallbacks.
    *   **Key Entities:** MarketplaceIndex, PluginEntry, PluginManifest, InstalledPluginRegistry, LifecycleScriptRecord, ChangelogMetadata.
    *   **Diagram (PlantUML - ERD):**
        ~~~plantuml
        @startuml
        hide circle
        skinparam linetype ortho
        skinparam monochrome false
        skinparam shadowing false
        skinparam defaultTextAlignment left
        ' ERD reflecting JSON entities defined in the foundation.
        ' Each entity represents a JSON document or logical array persisted within the repository structure.

        ' MarketplaceIndex captures repository-level manifest metadata.
        entity "MarketplaceIndex" as MarketplaceIndex {
            *version : semver
            *generatedAt : datetime
            generatorVersion : string
            checksumAlgorithm : string
            signature : string
        }

        ' PluginEntry mirrors curation data for each plugin listing.
        entity "PluginEntry" as PluginEntry {
            *id : string
            name : string
            category : enum(10 values)
            repo : url
            manifestPath : path
            latestVersion : semver
            checksum : sha256
            changelogUrl : url
            deprecated : boolean
            pinPriority : integer
        }

        ' PluginManifest encodes runtime expectations and compatibility data.
        entity "PluginManifest" as PluginManifest {
            *id : string
            *version : semver
            description : text
            entry : path
            permissions : json[]
            lifecycle : json
            compatibility.nodeMin : semver
            compatibility.nodeMax : semver
            compatibility.os : string[]
            compatibility.arch : string[]
            compatibility.claude : string[]
            installNotes : markdown
            hashes : map
            signing : json
            configSchema : json?
        }

        ' InstalledPluginRegistry records install state and telemetry snapshots.
        entity "InstalledPluginRegistry" as InstalledPluginRegistry {
            *registryVersion : semver
            installed[] : json array (pluginId, version, cachePath, symlinkTarget, installState, source)
            activePins[] : json array (pluginId, version, priority)
            telemetrySnapshots[] : json array (transactionId, durationMs, verdicts)
            lastValidatedAt : datetime
        }

        ' LifecycleScriptRecord stores consent and execution details for hooks.
        entity "LifecycleScriptRecord" as LifecycleScriptRecord {
            *pluginId : string
            *version : semver
            scriptType : enum(preInstall, postInstall, uninstall)
            digest : sha256
            lastConsentAt : datetime
            lastExecutedAt : datetime
            exitCode : integer
            durationMs : integer
            justification : text
        }

        ' ChangelogMetadata documents changelog retrieval outcomes.
        entity "ChangelogMetadata" as ChangelogMetadata {
            *pluginId : string
            *version : semver
            url : url
            retrievedAt : datetime?
            status : enum(success, timeout, fetch-error, missing)
            note : text
        }

        ' Relationships among entities preserve traceability across commands.
        MarketplaceIndex ||--o{ PluginEntry : "contains entries"
        PluginEntry ||--|| PluginManifest : "latest manifest reference"
        PluginManifest ||--o{ LifecycleScriptRecord : "declares lifecycle scripts"
        PluginEntry ||--o{ ChangelogMetadata : "points to changelog fetch records"
        InstalledPluginRegistry ||--o{ PluginManifest : "tracks installed version reference"
        InstalledPluginRegistry ||--o{ LifecycleScriptRecord : "records consent/execution history"
        InstalledPluginRegistry ||--o{ ChangelogMetadata : "stores last changelog fetch status per installed plugin"
        PluginManifest ||--o{ PluginEntry : "historical versions inform marketplace suggestions"

        ' Additional notes: InstalledPluginRegistry arrays reference pluginIds instead of duplicating manifests, minimizing drift.
        ' LifecycleScriptRecord persists digests so CLI can verify scripts match prior consent before execution.
        ' ChangelogMetadata status fields inform CLI messaging when changelog fetches fail gracefully.

        @enduml
        ~~~
    *   **Data Governance & Structural Notes:**
        - MarketplaceIndex files are regenerated through deterministic scripts, so the CLI stores `generatorVersion` and `checksumAlgorithm` inside the entity to confirm provenance before trusting entries.
            When a delta is detected, the CLI flags stale caches and prompts the developer to pull or regenerate indexes, reinforcing FR-002 traceability goals.
        - PluginEntry objects reference manifest paths relative to each plugin repository, enabling multi-repo setups without rewriting the schema; the CLI normalizes these paths before handing them to infrastructure adapters.
            The curated metadata also includes `pinPriority`, which domain services use to resolve conflicts when multiple entries map to the same logical plugin ID.
        - PluginManifest compatibility arrays are persisted verbatim in the installed registry so compatibility verdicts can be reproduced when running rollbacks offline.
            This approach supports CRIT-019 by keeping `nodeMax` alongside `nodeMin`, OS, arch, and Claude runtime data with no dependency on live telemetry.
        - InstalledPluginRegistry's `telemetrySnapshots[]` array stores structured timing and verdict data, providing the audit trail mandated by adversarial reviewers without introducing a separate telemetry database.
            Because the registry is written atomically, telemetry snapshots and install state transitions remain consistent even if the CLI crashes mid-operation.
        - LifecycleScriptRecord entries are stored per `(pluginId, version, scriptType)`, pairing a digest with justification text so the CLI can reject altered scripts automatically.
            The domain layer references these records before every lifecycle execution, protecting against tampering and satisfying CRIT-004 safeguards.
        - ChangelogMetadata entries preserve fetch results for both success and failure paths; the `note` field stores friendly fallback messaging cues that the CLI replays when network errors occur.
            This ensures CRIT-008 compliance by treating changelog download failures as warnings rather than blockers while still documenting reasons.
        - All entities rely on Git for distribution, so structural documentation includes references to `.github/workflows/validate-schemas.yml` where schema validation is enforced on every push.
            The CI workflow surfaces the same data contracts, preventing drift between local development and remote enforcement.
        - JSON Schema Draft-07 definitions stored under `/schemas` remain the single source of truth for validation logic, but the ERD documents conceptual relationships for architects who need a broader system view.
            This duality lets schema editors and structural architects collaborate without duplicating requirements.
        - Feature flags stored in `.claude-plugin/flags.json` reference entity names and command identifiers, binding runtime toggles to structural artifacts; the config module interprets them before domain logic executes.
            As a result, experimental entities or relationships can be introduced safely without destabilizing production-ready flows.
        - Documentation for each contract lives alongside diagrams under `docs/diagrams/`, and every change to entities or relationships must update both the ERD and the traceability matrix.
            This keeps the 100% coverage metric intact and provides downstream teams with authoritative blueprints.
    *   **Structural Interface Inventory:**
        - `cli` → `domain` contracts cover command handlers such as `installCommand`, `publishCommand`, `rollbackCommand`, `browseCommand`, and `searchCommand`; each exposes typed request/response objects plus telemetry context to avoid reliance on ambient globals.
            The CLI therefore remains thin, focusing on UX concerns while deferring validation and business rules to the domain layer.
        - `domain` → `infrastructure` interfaces include `GitProvider`, `FileSystemProvider`, `SchemaValidator`, `LifecycleSandboxRunner`, `TelemetrySink`, and `SymlinkManager`.
            These abstractions enable deterministic testing because vitest suites can swap in in-memory implementations when exercising install flows.
        - Domain service interfaces such as `MarketplaceIndexService`, `PluginValidationService`, `CompatibilityService`, `InstallService`, `CacheService`, and `TelemetryService` are described using TypeScript interfaces located in the domain package's `contracts/` directory.
            Each service exposes methods returning discriminated union `Result` types, avoiding thrown errors and aligning with the foundation's error-handling directive.
        - Event-like outputs are modeled as structured telemetry events (`InstallStarted`, `InstallCompleted`, `InstallRolledBack`, `LifecycleConsentRecorded`, etc.) written to JSON logs and Prometheus snapshots.
            This maintains observability without introducing messaging queues, satisfying both the Rulebook and Safety Net sections.
        - Configuration access flows through a single `config.ts` module that merges `.claude-plugin/config.json`, environment variables, and CLI options in priority order.
            No other component may read `process.env` directly, ensuring consistent precedence semantics.
        - Feature flags are evaluated at the command preflight stage; once a flag disables a given journey, downstream services never execute related code paths.
            This structural choice keeps complexity localized and prevents partial command execution.
        - Documentation contracts (stored under `docs/contracts/`) mirror CLI request/response shapes so that typedoc outputs, markdown references, and PlantUML diagrams all describe the same interfaces.
            Maintaining this mirroring supports the traceability matrix's requirement for 100% coverage.

    *   **Static Dependency Rules:**
        - Linting enforces that `cli` imports only from `domain` and shared type packages, while `domain` imports only from shared types and never from `cli`; `infrastructure` imports from shared utilities but not from `cli`.
            Dependency-cruiser or ESLint import rules ensure these constraints remain automated, preventing future architectural drift.
        - Circular dependency detection runs within CI to guarantee that no new modules break the layered architecture, aligning with the blueprint directive for strict separation of concerns.
            When violations are detected, the rule references `FR-012` remediation steps documented in the traceability matrix.
        - Shared type definitions (error codes, telemetry event formats, entity DTOs) live in a `domain/contracts` subpackage, and only this subpackage may be imported across layers.
            This keeps implementation details encapsulated while letting other teams consume consistent data contracts.
        - Any new adapters or services must document their interface within `docs/contracts/` and add entries to the traceability matrix, maintaining the spec's 100% coverage metric.
            Structural diagrams should be updated simultaneously so visual artifacts always match code boundaries.
        - Dockerized CI steps rely on Node 20 slim images pinned by digest; this is captured structurally within `.github/workflows/validate-schemas.yml` and referenced by architecture docs to avoid ambiguous runtime assumptions.
            Local scripts mirror the same container definitions, minimizing "works on my machine" discrepancies.
        - The repository forbids global installations of dependencies; pnpm workspaces ensure each package declares explicit dependencies and publishes only TypeScript interfaces as cross-layer contracts.
            This structural rule keeps dependency surfaces tight and aligns with the foundation's medium-scale classification.
    *   **Traceability Hooks:**
        - Every diagram resides under `docs/diagrams/` with filenames matching anchor IDs so cross-references in `docs/SPECIFICATION.md` can link directly to the Structural_Data_Architect assets.
            The anchors inserted before each heading make it trivial for automation to assemble navigation tables without manual editing.
        - Pull requests must cite FR/NFR IDs plus relevant anchor keys (e.g., `<!-- anchor: 3-1-architectural-style -->`) in their descriptions to maintain requirement lineage.
            This practice keeps the traceability matrix synchronized with structural artifacts and ensures audits can map code changes back to approved designs.
        - Traceability metadata is also mirrored inside `docs/traceability-matrix.md`, where each anchor maps to FR/NFR coverage entries maintained by Ops_Docs_Architect.
            Keeping these references synchronized guarantees the documented 100% coverage metric remains verifiable during adversarial review.
